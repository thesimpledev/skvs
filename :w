package main

import (
	"bytes"
	"io"
	"log/slog"
	"testing"
)

type te struct{}

func (e *te) Encrypt(input []byte) ([]byte, error) {
	return input, nil
}

func (e *te) Decrypt(input []byte) ([]byte, error) {
	return input, nil
}

func newTestApp() *application {
	config := &config{
		port: 8080,
	}

	logger := slog.New(slog.NewTextHandler(io.Discard, nil))

	e := &te{}

	app := &application{
		cfg:       config,
		log:       logger,
		encryptor: e,
		skvs:      make(map[string][]byte),
	}

	return app
}

func TestSet(t *testing.T) {
	tests := []struct {
		name       string
		key        string
		initial    []byte
		value      []byte
		overwrite  bool
		old        bool
		wantMap    []byte
		wantReturn []byte
	}{
		{
			name:       "set new key",
			key:        "foo",
			initial:    nil,
			value:      []byte("bar"),
			overwrite:  false,
			old:        false,
			wantMap:    []byte("bar"),
			wantReturn: []byte("bar"),
		},
		{
			name:       "overwrite existing key return new key",
			key:        "foo",
			initial:    []byte("initial"),
			value:      []byte("bar"),
			overwrite:  true,
			old:        false,
			wantMap:    []byte("bar"),
			wantReturn: []byte("bar"),
		},
		{
			name:       "over write existing key return old key",
			key:        "foo",
			initial:    []byte("initial"),
			value:      []byte("bar"),
			overwrite:  true,
			old:        true,
			wantMap:    []byte("bar"),
			wantReturn: []byte("initial"),
		},
		{
			name:       "do not overwrite, return old value",
			key:        "foo",
			initial:    []byte("initial"),
			value:      []byte("bar"),
			overwrite:  false,
			old:        true,
			wantMap:    []byte("initial"),
			wantReturn: []byte("initial"),
		},
		{
			name:       "overwrite nil key return new key",
			key:        "foo",
			initial:    nil,
			value:      []byte("bar"),
			overwrite:  true,
			old:        false,
			wantMap:    []byte("bar"),
			wantReturn: []byte("bar"),
		},
		{
			name:       "over write nil key return old key",
			key:        "foo",
			initial:    nil,
			value:      []byte("bar"),
			overwrite:  true,
			old:        true,
			wantMap:    []byte("bar"),
			wantReturn: []byte(""),
		},
		{
			name:       "do not overwrite nil key, return old value",
			key:        "foo",
			initial:    nil,
			value:      []byte("bar"),
			overwrite:  false,
			old:        true,
			wantMap:    []byte("bar"),
			wantReturn: []byte(""),
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			app := newTestApp()
			if tt.initial != nil {
				_ = app.set(tt.key, tt.initial, false, false)
			}
			got := app.set(tt.key, tt.value, tt.overwrite, tt.old)

			if string(got) != string(tt.wantReturn) {
				t.Errorf("set() = %v, want %v", string(got), string(tt.wantReturn))
			}

			if string(app.skvs[tt.key]) != string(tt.wantMap) {
				t.Errorf("sksv = %v, want %v", string(app.skvs[tt.key]), string(tt.wantMap))
			}
		})
	}
}

func TestGet(t *testing.T) {
	app := newTestApp()

	want := []byte("Jack")

	_ = app.set("cat", want, false, false)

	got := app.get("cat")

	if !bytes.Equal(got, want) {
		t.Errorf("expected %v, got %v", want, got)
	}
}

func TestDel(t *testing.T) {
	app := newTestApp()

	want := []byte("Jack")

	_ = app.set("cat", want, false, false)

	got := app.del("cat")

	if !bytes.Equal(want, got) {
		t.Errorf("delete return - want %v, got %v", want, got)
	}

	if !bytes.Equal(app.skvs["cat"], nil) {
		t.Errorf("delete map after - want nil, got %v", got)
	}
}

func TestExists(t *testing.T) {
	tests := []struct {
		name string
		key string
		value []byte
		want []byte
	}{
		{
			name: "item exists",
			key: "cat",
			value:[]byte("jack"),
			want: []byte("1"),

		},
		{
			name: "item doesn't exist",
			key: "dog",
			want: []byte("0"),
		},
	}
	
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T){
			app.newTestApp()

			if tt.value != nil {
				_ = app.set(tt.key, tt.value, false, false)
			}

			got := app.exists(key)

			if !compare(tt.want, got) {
				t.Errorf("want %v, %got %v", tt.want, got)
			}
		})
	}

}
